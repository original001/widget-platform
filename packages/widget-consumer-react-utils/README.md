# Библиотека для отрисовки виджета в контейнере потребителя с помощью React

Эта библиотека имеет target: ESNext. Транспилировать библиотеку под необходимое окружение в браузере - ответственность потребителя. CRA и Vite транспилируют автоматически.

## React-компонент `WidgetRenderer`

Компонент автоматически управляет HTMLElement-контейнером для отрисовки виджета. При отображении компонент сам создает компонент и рендерит виджет. При скрытии компонента, вызывает `dispose` у виджета и убирает контейнер.
Решает множество гонок, сохраняет и перевыбрасывает неожиданные ошибки (как при рендере, так и в коллбэке), рисует лоадер и ожидаемые ошибки, позволяет повторить загрузку виджета, предоставляет каждому инсансу виджета свой независимый контейнер для асинхронного dispose.
Компонент можно использовать по-разному. Некоторые рекомендованные варианты есть в примерах ниже.

Виджет будет перерисован при изменении функции отрисовки. Если используешь `WidgetRenderer`, рекомендуем оборачивать renderWidget в `usePersistentCallback` (см. ниже) вместо `useCallback`, так как стандартный хук не гарантирует того, что функция не будет создаваться каждый раз заново.

Важно: если виджет не отрисовывается в контейнере потребителя в дереве react-компонентов потребителя, то этот компонент не подходит.

## Хук `usePersistentCallback`

В отличие от стандартного `useCallback` обладает гарантией постоянности: не изменится, пока не поменялись зависимости.

## Установка
`npm install @skbkontur/operation-result`

`npm install @skbkontur/widget-consumer-react-utils`

## Примеры

Работу примеров можно посмотреть в Storybook: `npm run storybook`.

[Простой пример](./examples/Widget.tsx) внутреннего виджета.

### Потребители

В потребителях виджетов (не playground) важно:
* Отображение простых ошибок пользователю с возможностью повторить загрузку виджета.
* Загрузка модуля (фронтового API) только когда требуется отрисовка (даже для двухэтапных виджетов).

Использовать фронтовое API можно двумя способами:
* Без кеширования: На каждый рендер создается новое фронтовое API. При этом само API может быть одноуровневым (отрисовка сразу после вызова createWidgetApi), так и двухуровневым (нужно функцию отрисовки вызывать отдельно).
* C кешированием: Фронтовое API можно запросить и убрать без отображения виджета. Используя одну копию фронтового API, виджет можно рендерить несколько раз, либо вызывать разные функции рендера. Фронтовое API должно быть двухуровневым.

### Примеры
* [Пример для module-federation](./examples/module-federation/Widget.tsx).
* [Пример для старого loader-builder](./examples/commonjs/oldLoaderBuilder/Widget.tsx) (версии 1.1.0 и ниже).
* Примеры для нового loader-builder перечислены ниже:

#### CommonJS
Если потребитель на CommonJS, а npm-loader поддерживает только ESM, то потребуется использовать `mts`-файлы.

* [Пример для виджета](./examples/commonjs/oneStep/Widget.tsx) с одним этапом инициализации.
* [Пример для виджета](./examples/commonjs/twoStep/Widget.tsx), с двумя этапам инициализации, но без кеширования.
* [Пример для виджета](./examples/commonjs/twoStepWithCache/Widget.tsx), с двумя этапам инициализации с кешированием через глобальную переменную.

#### ESM
Если потребитель на ESM или npm-loader поддерживает commonjs, то используется упрощенная схема.

* [Пример для виджета](./examples/esm/oneStep/Widget.tsx) с одним этапом инициализации.
* [Пример для виджета](./examples/esm/twoStep/Widget.tsx), с двумя этапам инициализации, но без кеширования.
* [Пример для виджета](./examples/esm/twoStepWithCache/Widget.tsx)  с двумя этапам инициализации с кешированием через глобальную переменную.

### Playground

Для построения playground помимо свойств выше требуются еще фичи. Для их реализации написана еще одна библиотека [skbkontur/widget-playground](../widget-playground/README.md), с помощью которой можно использовать текущую (`@skbkontur/widget-consumer-react-utils`).

* [Минимальный пример](../widget-playground/examples/Minimal/WidgetModule.tsx) для запуска внутри Storybook, есть в пакете с самой библиотекой.
* [Расширенный пример](../widget-playground/examples/Standard/PlaygroundTwoStep.tsx), есть в пакете с той же библиотекой. Подходит как для запуска внутри Storybook, так и в произвольном сервере.
* Пример использования библиотеки в [стандартном шаблоне на react](../template/playground/WidgetController.tsx) для старта виджетов.

