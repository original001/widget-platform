# Библиотека для организации взаимодействия потребителя виджета и виджета.

Эта библиотека написана в синтаксисе ES Module и имеет target: ESNext.
Транспилировать библиотеку под необходимое окружение - ответственность потребителя. CRA и Vite транспилируют автоматически.

Функции библиотеки никогда не выбрасывают исключения и ожидают, что потребитель не будет выбрасывать исключения. В качестве принимаемых и возвращаемых значений используется тип `OperationResult` из библиотеки `@skbkontur/operation-result`. Для создания и проверки успеха можно использовать функции-утилиты из этой библиотеки.

## Установка
`npm install @skbkontur/operation-result`

`npm install @skbkontur/loader-builder`

## Определения

-   Потребитель виджета - сервис, в который виджет встраивается.
-   Виджет - это ES Module с экспортируемой функцией `createWidgetApi`, который где-то хостится и доступен по `URL` из браузера пользователя со страницы потребителя виджета.
-   `js-loader` - это ES Module с экспортируемой функцией `createWidgetApi`, который не является виджетом, но умеет получать зависимости виджета, загружать виджет уже по несколько новому `URL` и выполнять его код. Изменения `js-loader` не требуют перевыпуска приложений-потребителей и обновляется вместе с виджетом. Виджет и `js-loader` могут быть в одном чанке бандла.
-   `npm-loader` - это пакет, подключаемый потребителем виджета, который умеет получать зависимости виджета, загружать виджет или `js-loader` и выполнять его код. Также предоставляет типы для потребителя.

Теоретически можно использовать виджет в потребителе без `loader-builder`, но библиотека предоставляет ряд дополнительных типов и функций, которые позволяют сделать схему более надежной, удобной и добавить ряд фич в виде декораторов или уточнений типов для пайплайна инициализации виджета.

`loader-builder` обеспечивает:

1. Типизированный интерфейс взаимодействия самого виджета и приложений-портебителей;
2. Загрузку, кеширование и исполнение модуля виджета;
3. Изоляцию модуля виджета;
4. Обработку ошибок.

## `loader-builder` cостоит из нескольких компонентов:

### Типы

1. Обязательный тип `CreateWidgetApi`, который описывает функцию, которую необходимо реализовать и экспортировать в ES-модуле виджета.
   Сама функция должна иметь имя `createWidgetApi`.

Определение:

```typescript
type CreateWidgetApi<TDependencies, TFault, TWidgetApi> = (param: {
    dependencies: TDependencies;
}) => Promise<OperationResult<TFault, TWidgetApi>>;
```

-   `TDependencies` - это зависимости виджета, которые необходимо получить явно виджету от потребителя. Если зависимостей нет, либо они используются неявно (например, как `externals`), то нужно указать `WidgetDependenciesConstraint`.
-   `TFault` - ошибки которые могут произойти при создании API виджета. Если ошибок произойти не может, то нужно указать `never`.
-   `TWidgetApi` - предоставляемое вашим виджетом фронтовое API. Может быть любым, но рекомендуется использовать объект, расширяющий тип `Disposable`. В простых случаях рекомендуется использовать описанный далее стандартный `DefaultWidgetApi`.

Простейший пример реализации:

```typescript
type WidgetApi = (container: HTMLElement) => void;

export const createWidgetApi: CreateWidgetApi<WidgetDependenciesConstraint, never, WidgetApi> = async () =>
  createSuccess((container) => container.appendChild(document.createTextNode("From widget!")));
```

Данный виджет предоставляет в качеcтве API функцию, которую потребитель может вызвать, передав в нее `HTMLElement`.

2. Опциональные типы `Disposable`, `DefaultWidgetApi`, `InitWidget` и `WidgetInitResult`, которые описывают стандартное фронтовое API предоставляемое загруженным модулем виджета.

```typescript
type Disposable<TDisposeFault> = {
    dispose(): Promise<OperationResult<TDisposeFault, void>>;
};

type WidgetModule<TDisposeFault, TInit> = {
    init: TInit;
} & Disposable<TDisposeFault>;

type InitWidget<TParams, TFault, TResult> = (params: TParams) => Promise<OperationResult<TFault, TResult>>;

type WidgetInitResult<TDisposeFault> = {} & Disposable<TDisposeFault>;
```

В качестве параметров инициализации `TParams` виджета лучше использовать объект с полем `HTMLElement` вместо `containerId`, чтобы виджет работал в своем контексте, работала изоляция `iframe`, передача параметров была явной, а код не дублировался.

Опциональные типы необязательно использовать, но рекомендуется так как:

-   Часть фич `loader-builder` использует этот интерфейс;
-   Позволяют расширять API загруженного модуля виджета без поломки обратной совместимости;
-   Используется в текущих виджетах, что позволяет упростить подключение в приложениях-потребителях.

Модуль виджета (в виде фронтового API) рекомендуется загружать один раз на приложение-потребитель для целей кеширования, не вызывая у него `dispose` до покидания страницы пользователем.
Инициализировать же виджет можно несколько раз: каждый раз когда пользователь уходит со страницы вызывать `dispose`, когда приходит - `init`.

### Загрузчики

Загрузчики позволяют загрузить на страницу следующий в цепочке `js`-модуль виджета, в котором экспортируется функция `createWidgetApi`, по `URL` этого скрипта.
Загрузчики используются в основе `npm-loader` (с помощью которого можно построить npm-пакет для приложения в которое виджет встраивается) и в `js-loader`.

Все загрузчики возвращают ошибки с типами, перечисленными в объекте `ImportFaultTypes`.

1. `importWidgetModule` - просто загружает модуль виджета по `URL` и вызывает функцию `createWidgetApi`.
   Если опустить типизацию, валидацию и обработку ошибок, то реализация выглядит так:

```typescript
async function importWidgetModule({ widgetUrl, dependencies }) {
    const { createWidgetApi } = await import(widgetUrl);
    return await createWidgetApi({ dependencies });
}
```

Использование в npm-loader выглядит так:

```typescript
import * as react from "react";
import * as reactDOM from "react-dom";

const dependencies = {react, reactDOM} as const;
type ImportFaults = never;
type WidgetApi = (container: HTMLElement) => void;

export function importMyWidgetModule({
                              widgetUrl,
                            }): Promise<OperationResult<AddImportWidgetModuleFaults<ImportFaults>, WidgetApi>> {
  return importWidgetModule<typeof dependencies, ImportFaults, WidgetApi>({widgetUrl, dependencies});
}
```

Зависимостями может быть все что угодно. Например:

-   Externals сборщика бандла виджета для переиспользования больших пакетов между потребителем виджета и виджетом или между разными виджетами. Например, `react` и `react-dom`.
-   Дополнительные зависимости или структуры, которые нужно прокинуть в `iframe` из `js-loader`. Например, `react-focus-lock`.
-   `Promise` начального состояния (state) виджета, получаемого от API бэкенда виджета. Это полезно, чтобы загружать, стейт с бэкенда и скрипты паралельно.
-   `Promise` импортов пространств имен других модулей, которые хочется загружать параллельно с основным модулем виджета.
-   Данные для инициализации состояния виджета (api URL, `organizationId`). При этом данные для отрисовки виджета (контейнер `HTMLElement`, функция генерации ссылок) рекомендуется передавать через `InitWidgetParams` внутри опционального типа `DefaultWidgetApi`, а не через аргумент `dependencies` функции `importWidgetModule`.

Нужно учесть, что чем больше используется зависимостей в `npm-loader`, тем более вероятно, что их потребуется изменить (например, обновить мажорную версию библиотеки). А это потребует перевыпуска всех приложений-потребителей.
А это вторая из двух основных причин разработчику виджета перевыпускать приложения-потребители (первая - это изменение публичного контракта, т.е. фронтового API модуля виджета).

2. `importWidgetModuleViaIframe` - загружает модуль виджета по `URL` внутри `friendly iframe` и вызывает функцию `createWidgetApi`.
   Требует фронтовому API модуля виджета быть объектом реализующим интерфейс `Disposable`, так как добавляет в вызов `dispose` удаление `iframe` из `DOM` и очистку используемых ресурсов.

`importWidgetModuleViaIframe` можно использовать как в `npm-loader`, так и в `js-loader`, но рекомендуется использовать вызывать только в `js-loader` чтобы иметь возможность обновить алгоритм работы с `iframe` и изменить зависимости (в том числе версию `react-ui`) без перевыпуска приложения-потребителя.

`friendly iframe` обеспечивает:

-   Возможность экономии ресурсов, если приложение потребитель вызывает `dispose` у модуля виджета, когда виджет перестал быть необходимым. Это позволяет освобождать память когда модуль становится недоступен (без этого не получится, так как если загрузить скрипты и es-модули в без `iframe`, они никогда не будут выгружены). Память будет освобождена только если ссылок на код в `iframe` в приложении-потребителе не осталось. Декоратор `fixWidgetApiDisposes` позволяет частично обрывать ссылки на удаленный `iframe`.
-   Изоляцию кода модуля виджета.
-   Возможность подписки на глобальные обработчики событий (например, `onerror` или `onunhandledrejection`).
-   Изоляцию глобальных переменных.

Предварительная настройка `window`, выполняемая до загрузки модуля виджета, выполняется с помошью аргумента `configureContentWindow`.

Внимание: не все npm-пакеты корректно работают если загружены внутри `iframe`.
Это относится к тем пакетам, которые используют глобальный `window` или `document`.
Например, не будет работать `react-focus-lock` из `react-ui`. Для таких пакетов нужно:

-   Либо преобразовать с помощью плагина `transform-globals` для `babel` обращения к `window`;
-   Либо получить их в модуле виджета как зависимость. Передать их можно:
    -   Либо из `npm-loader` получив зависимость от приложения-потребителя (не рекомендуется, так как сложно менять мажорную версию такой зависимости);
    -   Либо из `js-loader`, забандлив в него зависимость.

Некоторые другие пакеты (например, `react-ui`) или плагины (например, `style-loader`), которые предназначены для отрисовки, нужно настроить, чтобы они использовали `window` потребителя.

### Декораторы

1. Превратить необработанные исключения в `OperationResult`: `catchWidgetApiFaults`.
   Принимает `DefaultWidgetApi` и возвращает `DefaultWidgetApi`, который не выкидывает исключения во всех 3-х функциях типа.
   Меняет типы возвращаемых ошибок, добавляя к ним `UnexpectedFault`.

2. Обеспечить корректную систему `dispose`: `fixWidgetApiDisposes`.

Используется, так как часто паттерн `Disposable` разработчики виджета реализуют некорректно.

Принимает `DefaultWidgetApi` и возвращает `DefaultWidgetApi` с новыми ошибками.

-   Обеспечивает, чтобы `dispose` у модуля и результата инициализации можно было вызвать один раз.
-   Удаляет ссылки на виджет после вызова `dispose` модуля (это позволяет выгрузить скрипты при использовании `iframe`).
-   Запрещает инициализировать модуль виджета, у которого был вызван `dispose`.
-   Вызывает `dispose` у всех результатов инициализации при вызове `dispoose` у модуля.

## Функции-утилиты для OperationResult

В пакете есть функция `tryExecute` для создания `OperationResult` с типом ошибки из `loader-builder`.
Остальные функции и типы можно найти в пакете `@skbkontur/operation-result`.

## Настройка `webpack` для сборки виджета

См. пакет `"@skbkontur/widget-webpack-utils"`
